{% for _, backend in backends.items() -%}
upstream {{ backend.upstream_identifier }} {
    server {{ backend.hostname }}:{{ backend.port }};
    keepalive 8;
}

{% endfor -%}

server {
  listen [::]:80;
  server_name {{ server_name }};
  charset utf-8;
  return 301 https://$server_name$request_uri;
}

server {
  listen [::]:443 ssl;
  server_name {{ server_name }};
  charset utf-8;

  client_max_body_size 10m;

  ssl_certificate {{ cert }};
  ssl_certificate_key {{ key }};
  add_header Strict-Transport-Security max-age=31536000 always;

  error_page 504 /504-{{ server_name }}.html;

  {% for extra_server_dict in extra_server_config -%}
  {% for key, value in extra_server_dict.items() -%}
  {{ key }} {{ value }};
  {% endfor -%}
  {% endfor %}

  {% for url, backend in backends.items() -%}
  location {{ url }} {
    proxy_pass {{ backend.protocol }}://{{ backend.upstream_identifier }};
    include proxy_params;
    include cache_params;

    # Override the HTTP Host header to the name of the upstream host.
    # (eg. *.herokuapp.com, prevents having to configure Heroku with the
    # correct hostname)
    proxy_set_header Host "{{ backend.upstream_hostname }}";

    proxy_ssl_trusted_certificate '{{ backend.upstream_trust_root }}';
    proxy_ssl_name {{ backend.hostname }};

    # The verification depth needed for Heroku is currently only 2, but since they might
    # change CA and certificate layout on a whim we allow a depth of 3.
    proxy_ssl_verify_depth 3;
  }

  {% endfor -%}

  location = /504-{{ server_name }}.html {
    root html;
    internal;
  }
}
